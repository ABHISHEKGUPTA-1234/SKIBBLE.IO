<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Skribbl.io Clone</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Base styles for body and overall layout */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5; /* Light gray background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Full viewport height */
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        /* Container for the entire game interface */
        .game-container {
            background-color: #ffffff;
            border-radius: 1rem; /* Rounded corners for the container */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1); /* Soft shadow */
            padding: 1.5rem;
            width: 100%;
            max-width: 1000px; /* Increased max width to accommodate chat/players */
            display: flex;
            flex-direction: row; /* Layout changed to row for game area and sidebar */
            gap: 1.5rem; /* Spacing between sections */
            align-items: flex-start; /* Align items to the top */
        }

        /* Main game area (canvas, drawing tools, controls, info) */
        .main-game-area {
            flex: 3; /* Takes more space */
            display: flex;
            flex-direction: column;
            gap: 1rem;
            align-items: center;
        }

        /* Sidebar for players and chat */
        .sidebar {
            flex: 1; /* Takes less space */
            display: flex;
            flex-direction: column;
            gap: 1rem;
            min-width: 200px; /* Minimum width for sidebar */
        }

        /* Styling for the drawing canvas */
        canvas {
            background-color: #e2e8f0; /* Light gray background for canvas */
            border: 2px solid #cbd5e1; /* Border around canvas */
            border-radius: 0.75rem; /* Slightly rounded canvas corners */
            cursor: crosshair; /* Cursor indicates drawing */
            touch-action: none; /* Prevent browser default touch gestures (e.g., scrolling) */
            width: 100%; /* Make canvas responsive to its container */
            max-width: 760px; /* Max width to fit container padding */
            height: 400px; /* Fixed height for the drawing area */
        }
        /* Flex container for game info, controls, and guess section */
        .game-info, .game-controls, .chat-input-section, .drawing-tools {
            width: 100%;
            display: flex;
            flex-wrap: wrap; /* Allow items to wrap on smaller screens */
            justify-content: center;
            gap: 0.75rem; /* Spacing between items */
        }
        /* Base styling for buttons */
        .button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            transition: all 0.2s ease-in-out; /* Smooth transitions for hover effects */
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Subtle button shadow */
        }
        /* Primary button styling (e.g., Start Game, Submit Guess) */
        .button-primary {
            background-image: linear-gradient(to right, #6366f1, #8b5cf6); /* Gradient background */
            color: white;
            border: none;
        }
        .button-primary:hover {
            background-image: linear-gradient(to right, #4f46e5, #7c3aed); /* Darker gradient on hover */
            transform: translateY(-2px); /* Slight lift effect */
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15); /* Enhanced shadow on hover */
        }
        /* Secondary button styling (e.g., Clear Canvas) */
        .button-secondary {
            background-color: #e2e8f0;
            color: #334155;
            border: 1px solid #cbd5e1;
        }
        .button-secondary:hover {
            background-color: #cbd5e1;
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
        }
        /* Styling for text input fields */
        input[type="text"] {
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            border: 1px solid #cbd5e1;
            flex-grow: 1; /* Allows input to take available space */
        }
        /* Styling for color input */
        input[type="color"] {
            -webkit-appearance: none; /* Remove default browser styling */
            -moz-appearance: none;
            appearance: none;
            width: 40px; /* Fixed width for color picker */
            height: 40px; /* Fixed height for color picker */
            background-color: transparent;
            border: none;
            cursor: pointer;
            border-radius: 0.5rem; /* Rounded corners */
            overflow: hidden; /* Hide default color picker border */
            padding: 0;
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 0.5rem; /* Match parent border-radius */
        }
        input[type="color"]::-moz-color-swatch-wrapper {
            padding: 0;
        }
        input[type="color"]::-moz-color-swatch {
            border: none;
            border-radius: 0.5rem; /* Match parent border-radius */
        }
        /* Styling for range input (line width) */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100px; /* Fixed width for slider */
            height: 8px;
            background: #cbd5e1;
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type="range"]:hover {
            opacity: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #6366f1;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #6366f1;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* Styling for the message box */
        .message-box {
            background-color: #f0f9ff; /* Light blue background */
            color: #0c4a6e; /* Dark blue text */
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            border: 1px solid #90cdf4; /* Blue border */
            text-align: center;
            width: 100%;
        }
        /* Utility class to hide elements */
        .hidden {
            display: none;
        }

        /* Chat box specific styling */
        #chatBox {
            background-color: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 0.75rem;
            padding: 1rem;
            height: 300px; /* Fixed height for chat scroll */
            overflow-y: auto; /* Enable scrolling */
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }
        .chat-message {
            padding: 0.4rem 0.6rem;
            border-radius: 0.5rem;
            background-color: #f0f2f5;
            word-wrap: break-word; /* Ensure long words wrap */
        }
        .chat-message.system {
            background-color: #dbeafe; /* Light blue for system messages */
            color: #1e40af;
            font-weight: 500;
        }
        .chat-message.drawer-message {
            background-color: #fef3c7; /* Light yellow for drawer's messages */
            color: #92400e;
        }
        .chat-message.correct-guess {
            background-color: #d1fae5; /* Light green for correct guesses */
            color: #065f46;
            font-weight: 600;
        }

        /* Player list specific styling */
        #playerList {
            list-style: none;
            padding: 0;
            margin: 0;
            background-color: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 0.75rem;
            padding: 1rem;
        }
        #playerList li {
            padding: 0.4rem 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px dashed #e2e8f0;
        }
        #playerList li:last-child {
            border-bottom: none;
        }
        .player-name {
            font-weight: 600;
            color: #334155;
        }
        .player-score {
            font-weight: 700;
            color: #6366f1;
        }
        .drawer-indicator {
            color: #ef4444; /* Red for drawer */
            font-weight: 700;
            margin-left: 0.5rem;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .game-container {
                flex-direction: column; /* Stack sections vertically on small screens */
                align-items: center;
            }
            .main-game-area, .sidebar {
                width: 100%; /* Full width for both sections */
                flex: none; /* Remove flex grow */
            }
            .drawing-tools {
                flex-direction: column; /* Stack drawing tools vertically */
                align-items: center;
            }
        }
    </style>
    <!-- Socket.io client library -->
    <script src="/socket.io/socket.io.js"></script>
</head>
<body>
    <div class="game-container">
        <!-- Main Game Area -->
        <div class="main-game-area">
            <h1 class="text-3xl font-bold text-gray-800 mb-4 text-center">Multiplayer Skribbl.io Clone</h1>

            <div id="gameInfo" class="game-info">
                <p id="wordToDraw" class="text-xl font-semibold text-purple-700 hidden">Draw this: <span class="text-purple-900" id="currentWordDisplay"></span></p>
                <p id="timerDisplay" class="text-2xl font-bold text-blue-600 hidden">Time: <span id="timeRemaining">60</span>s</p>
                <p id="message" class="message-box">Connecting to server...</p>
            </div>

            <!-- Drawing tools section -->
            <div id="drawingTools" class="drawing-tools hidden">
                <label for="colorPicker" class="text-gray-700 font-medium">Color:</label>
                <input type="color" id="colorPicker" value="#334155" aria-label="Select drawing color">

                <label for="lineWidth" class="text-gray-700 font-medium ml-4">Line Width:</label>
                <input type="range" id="lineWidth" min="1" max="10" value="4" aria-label="Adjust line width">
                <span id="lineWidthDisplay" class="text-gray-700 font-medium ml-2">4</span>
            </div>

            <canvas id="drawingCanvas"></canvas>

            <div id="gameControls" class="game-controls">
                <button id="startGameBtn" class="button button-primary">Start Game</button>
                <button id="clearCanvasBtn" class="button button-secondary hidden">Clear Canvas</button>
            </div>
        </div>

        <!-- Sidebar for Players and Chat -->
        <div class="sidebar">
            <h2 class="text-2xl font-bold text-gray-800 mb-2">Players</h2>
            <ul id="playerList" class="mb-4">
                <!-- Player list items will be inserted here by JavaScript -->
            </ul>

            <h2 class="text-2xl font-bold text-gray-800 mb-2">Chat</h2>
            <div id="chatBox" class="flex-grow">
                <!-- Chat messages will be inserted here by JavaScript -->
            </div>
            <div class="chat-input-section">
                <input type="text" id="chatInput" placeholder="Type your guess or chat message..." aria-label="Type your guess or chat message">
                <button id="sendChatBtn" class="button button-primary">Send</button>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Element References ---
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const startGameBtn = document.getElementById('startGameBtn');
        const clearCanvasBtn = document.getElementById('clearCanvasBtn');
        const chatInput = document.getElementById('chatInput');
        const sendChatBtn = document.getElementById('sendChatBtn');
        const wordToDrawDisplay = document.getElementById('wordToDraw');
        const currentWordSpan = document.getElementById('currentWordDisplay');
        const messageBox = document.getElementById('message');
        const drawingTools = document.getElementById('drawingTools');
        const colorPicker = document.getElementById('colorPicker');
        const lineWidthControl = document.getElementById('lineWidth');
        const lineWidthDisplay = document.getElementById('lineWidthDisplay');
        const chatBox = document.getElementById('chatBox');
        const playerList = document.getElementById('playerList');
        const timerDisplay = document.getElementById('timerDisplay');
        const timeRemainingSpan = document.getElementById('timeRemaining');

        // --- Socket.io Connection ---
        // Connect to the Socket.io server. Assumes server is running on the same host and port.
        const socket = io();

        // --- Game State Variables (Client-side representation) ---
        let isDrawing = false; // Flag to track if the local user is currently drawing
        let lastX = 0; // Last X coordinate for drawing (local)
        let lastY = 0; // Last Y coordinate for drawing (local)
        let currentColor = colorPicker.value; // Current drawing color (local)
        let currentLineWidth = parseInt(lineWidthControl.value); // Current line width (local)
        let mySocketId = null; // Stores the local client's socket ID
        let currentDrawerId = null; // Stores the socket ID of the current drawer (received from server)

        // --- Canvas Drawing Functions ---

        /**
         * Sets up the drawing context with current color and line width.
         * This is called locally and when drawing properties are updated by the server.
         */
        function setupDrawingContext(color, width) {
            ctx.strokeStyle = color || currentColor;
            ctx.lineWidth = width || currentLineWidth;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
        }

        /**
         * Draws a line segment on the canvas.
         * This function is used for both local drawing and drawing received from the server.
         * @param {object} data - Contains x, y, lastX, lastY, color, width.
         */
        function drawLine(data) {
            ctx.strokeStyle = data.color;
            ctx.lineWidth = data.width;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';

            ctx.beginPath();
            ctx.moveTo(data.lastX, data.lastY);
            ctx.lineTo(data.x, data.y);
            ctx.stroke();
            ctx.closePath(); // Close path after each segment
            setupDrawingContext(); // Restore local drawing context
        }

        /**
         * Handles mouse down or touch start to begin drawing.
         * Only enabled if the current client is the drawer.
         * @param {MouseEvent|TouchEvent} e - The event object.
         */
        function startDrawing(e) {
            if (mySocketId !== currentDrawerId) return; // Only drawer can start drawing
            isDrawing = true;
            [lastX, lastY] = getCanvasCoordinates(e);
            // No need to beginPath/moveTo here, it's done in drawLine for each segment
        }

        /**
         * Handles mouse move or touch move to draw lines.
         * Emits drawing data to the server.
         * @param {MouseEvent|TouchEvent} e - The event object.
         */
        function draw(e) {
            if (!isDrawing || mySocketId !== currentDrawerId) return;
            e.preventDefault(); // Prevent scrolling on touch devices

            const [x, y] = getCanvasCoordinates(e);
            const drawingData = {
                x: x,
                y: y,
                lastX: lastX,
                lastY: lastY,
                color: currentColor,
                width: currentLineWidth
            };
            drawLine(drawingData); // Draw locally
            socket.emit('drawing', drawingData); // Send drawing data to server
            [lastX, lastY] = [x, y]; // Update last coordinates
        }

        /**
         * Handles mouse up/leave or touch end/cancel to stop drawing.
         */
        function stopDrawing() {
            isDrawing = false;
        }

        /**
         * Clears the canvas. This is usually triggered by the server.
         */
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        /**
         * Gets the coordinates of the mouse/touch event relative to the canvas.
         * @param {MouseEvent|TouchEvent} e - The event object.
         * @returns {number[]} - An array containing [x, y] coordinates on the canvas.
         */
        function getCanvasCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;

            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            return [(clientX - rect.left) * scaleX, (clientY - rect.top) * scaleY];
        }

        // --- UI Update Functions ---

        /**
         * Displays a message in the message box.
         * @param {string} msg - The message string to display.
         */
        function setMessage(msg) {
            messageBox.textContent = msg;
        }

        /**
         * Adds a chat message to the chat box.
         * @param {object} data - { user: string, text: string, type: string (optional, for styling) }
         */
        function addChatMessage(data) {
            const msgElement = document.createElement('div');
            msgElement.classList.add('chat-message');
            msgElement.textContent = `${data.user}: ${data.text}`;

            if (data.type === 'system') {
                msgElement.classList.add('system');
            } else if (data.type === 'drawer') {
                msgElement.classList.add('drawer-message');
            } else if (data.type === 'correct') {
                msgElement.classList.add('correct-guess');
            }

            chatBox.appendChild(msgElement);
            chatBox.scrollTop = chatBox.scrollHeight; // Auto-scroll to bottom
        }

        /**
         * Updates the player list display.
         * @param {object} playersData - Object of players from the server.
         */
        function updatePlayerList(playersData) {
            playerList.innerHTML = ''; // Clear current list
            for (const id in playersData) {
                const player = playersData[id];
                const listItem = document.createElement('li');
                listItem.innerHTML = `
                    <span class="player-name">${player.username}</span>
                    <span class="player-score">${player.score} points</span>
                `;
                if (id === currentDrawerId) {
                    const drawerIndicator = document.createElement('span');
                    drawerIndicator.classList.add('drawer-indicator');
                    drawerIndicator.textContent = '(Drawing)';
                    listItem.querySelector('.player-name').appendChild(drawerIndicator);
                }
                playerList.appendChild(listItem);
            }
        }

        /**
         * Enables or disables drawing tools and input based on whose turn it is.
         * @param {boolean} isMyTurnToDraw - True if it's the current client's turn to draw.
         */
        function toggleDrawingAndGuessing(isMyTurnToDraw) {
            if (isMyTurnToDraw) {
                drawingTools.classList.remove('hidden');
                clearCanvasBtn.classList.remove('hidden');
                chatInput.placeholder = 'Type your guess or chat message...'; // Still allow general chat
            } else {
                drawingTools.classList.add('hidden');
                clearCanvasBtn.classList.add('hidden');
                chatInput.placeholder = 'Type your guess here...'; // Encourage guessing
            }
        }

        // --- Event Handlers (Client -> Server) ---

        /**
         * Sends a chat message or guess to the server.
         */
        function sendChat() {
            const message = chatInput.value.trim();
            if (message === '') return;

            // If it's my turn to draw, the message is just chat.
            // Otherwise, it's a guess. The server will handle validation.
            socket.emit('guess', message); // All messages are sent as 'guess' for simplicity, server distinguishes.
            chatInput.value = ''; // Clear input after sending
        }

        // --- Socket.io Event Listeners (Server -> Client) ---

        socket.on('connect', () => {
            mySocketId = socket.id;
            setMessage('Connected to game server! Waiting for game to start...');
            addChatMessage({ user: 'System', text: 'You are connected.' });
            startGameBtn.classList.remove('hidden'); // Show start button once connected
        });

        socket.on('disconnect', () => {
            setMessage('Disconnected from server. Please refresh.');
            addChatMessage({ user: 'System', text: 'Disconnected from server.' });
            startGameBtn.classList.add('hidden'); // Hide start button on disconnect
            drawingTools.classList.add('hidden');
            clearCanvasBtn.classList.add('hidden');
            wordToDrawDisplay.classList.add('hidden');
            timerDisplay.classList.add('hidden');
            playerList.innerHTML = '';
            clearCanvas();
        });

        socket.on('chatMessage', (data) => {
            addChatMessage(data);
        });

        socket.on('updatePlayers', (playersData) => {
            updatePlayerList(playersData);
        });

        socket.on('gameStarted', (data) => {
            currentDrawerId = data.drawerId;
            startGameBtn.classList.add('hidden'); // Hide start game button
            wordToDrawDisplay.classList.remove('hidden');
            timerDisplay.classList.remove('hidden');
            currentWordSpan.textContent = data.hint; // Show hint initially
            setMessage(`Round started! ${currentDrawerId === mySocketId ? 'You are drawing!' : 'Someone else is drawing.'}`);
            clearCanvas(); // Clear canvas for new round
            toggleDrawingAndGuessing(mySocketId === currentDrawerId);
            updatePlayerList(data.players); // Update player list with scores and drawer
        });

        socket.on('wordToDraw', (word) => {
            // Only the drawer receives this event
            currentWordSpan.textContent = word;
            setMessage(`It's your turn to draw! Draw: "${word}".`);
        });

        socket.on('drawing', (data) => {
            // All clients (except the drawer who already drew locally) receive and draw this
            drawLine(data);
        });

        socket.on('clearCanvas', () => {
            clearCanvas();
            setMessage('Canvas cleared by the drawer.');
        });

        socket.on('changeColor', (color) => {
            currentColor = color; // Update local color
            setupDrawingContext(); // Apply to context
        });

        socket.on('changeLineWidth', (width) => {
            currentLineWidth = width; // Update local width
            lineWidthDisplay.textContent = currentLineWidth; // Update display
            setupDrawingContext(); // Apply to context
        });

        socket.on('timerUpdate', (time) => {
            timeRemainingSpan.textContent = time;
        });

        socket.on('roundOver', (data) => {
            setMessage(`Round Over! Reason: ${data.reason}`);
            currentWordSpan.textContent = ''; // Clear word display
            timerDisplay.classList.add('hidden');
            toggleDrawingAndGuessing(false); // Disable drawing/guessing
            startGameBtn.textContent = 'Play Again';
            startGameBtn.classList.remove('hidden'); // Show play again button
        });

        // --- Initial Setup and Responsiveness ---

        /**
         * Adjusts the canvas dimensions to match its CSS size.
         * For multiplayer, we don't save/restore drawing on client-side resize
         * because the server is the source of truth for drawing data.
         * A new round will clear the canvas anyway.
         */
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            setupDrawingContext(); // Re-apply drawing context after resize
            // In a multiplayer game, we don't restore drawing on client-side resize
            // as the server dictates the drawing state.
        }

        // Initial setup when the window loads
        window.addEventListener('load', () => {
            resizeCanvas(); // Perform initial canvas resize and setup
        });

        // Adjust canvas dimensions whenever the window is resized
        window.addEventListener('resize', resizeCanvas);

        // Initial setup of drawing context (before any drawing starts)
        setupDrawingContext();

        // --- Event Listeners ---
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);

        canvas.addEventListener('touchstart', startDrawing, { passive: false });
        canvas.addEventListener('touchmove', draw, { passive: false });
        canvas.addEventListener('touchend', stopDrawing);
        canvas.addEventListener('touchcancel', stopDrawing);

        startGameBtn.addEventListener('click', () => {
            socket.emit('startGame');
            setMessage('Starting game...');
        });
        clearCanvasBtn.addEventListener('click', () => {
            socket.emit('clearCanvas');
            setMessage('You cleared the canvas!');
        });

        sendChatBtn.addEventListener('click', sendChat);
        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendChat();
            }
        });

        colorPicker.addEventListener('input', (e) => {
            currentColor = e.target.value;
            setupDrawingContext();
            if (mySocketId === currentDrawerId) {
                socket.emit('changeColor', currentColor);
            }
        });

        lineWidthControl.addEventListener('input', (e) => {
            currentLineWidth = parseInt(e.target.value);
            lineWidthDisplay.textContent = currentLineWidth;
            setupDrawingContext();
            if (mySocketId === currentDrawerId) {
                socket.emit('changeLineWidth', currentLineWidth);
            }
        });
    </script>
</body>
</html>
